'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataProvider = getDataProvider;
exports.getUserConfigForDp = getUserConfigForDp;
exports.getUsersForDp = getUsersForDp;
exports.getAllUserConfigs = getAllUserConfigs;
exports.getDPsForUser = getDPsForUser;
exports.findDpWithRef = findDpWithRef;
exports.getPolling = getPolling;
exports.getCanceled = getCanceled;
exports.addDataProvider = addDataProvider;
exports.addUserConfig = addUserConfig;
exports.removeDpUser = removeDpUser;
exports.dataProviderExpired = dataProviderExpired;
exports.refetch = refetch;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _DataProvider = require('./DataProvider');

var _DataProvider2 = _interopRequireDefault(_DataProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dataProviders = {};
var userConfigs = {};
var keepAlivePollingMap = {};

// queries

function getDataProvider(dpId) {
  return dataProviders[dpId];
}

// returns config for given userId and dpId
function getUserConfigForDp(dpId, userId) {
  return userConfigs[userId][dpId];
}

// returns all user configs for given dpId
function getUsersForDp(dpId) {
  var r = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _lodash2.default.keys(userConfigs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var userId = _step.value;

      if (_lodash2.default.has(userConfigs[userId], dpId)) {
        r.push(userConfigs[userId][dpId]);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return r;
}

// returns all configs for given userId (dpId:cfg pairs)
function getAllUserConfigs(userId) {
  return userConfigs[userId];
}

// returns all data providers for given userId
function getDPsForUser(userId) {
  var r = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _lodash2.default.keys(userConfigs[userId])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var dpId = _step2.value;

      r.push(dataProviders[dpId]);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return r;
}

// finds a data provider with a given ref
function findDpWithRef(ref) {
  return _lodash2.default.findKey(dataProviders, function (dp) {
    return _lodash2.default.isEqual(dp.ref, ref);
  });
}

// returns polling value for given dpId
function getPolling(dpId) {
  return keepAliveDp(dpId) ? keepAlivePolling(dpId) : _lodash2.default.reduce(getUsersForDp(dpId), function (prev, _ref) {
    var polling = _ref.polling;
    return Math.min(polling, prev);
  }, Infinity);
}

// returns canceled status for given dpId
function getCanceled(dpId) {
  var dp = dataProviders[dpId];
  return !dp || !keepAliveDp(dpId) && _lodash2.default.isEmpty(getUsersForDp(dpId)) || dp.expired();
}

// modifications

// adds new Data Provider
function addDataProvider(config) {
  dataProviders[config.id] = new _DataProvider2.default(config);
}

// adds new config for given userId - dpId
function addUserConfig(userId, dpId, _ref2) {
  var _ref2$needed = _ref2.needed,
      needed = _ref2$needed === undefined ? true : _ref2$needed,
      _ref2$polling = _ref2.polling,
      polling = _ref2$polling === undefined ? Infinity : _ref2$polling,
      _ref2$injectLoading = _ref2.injectLoading,
      injectLoading = _ref2$injectLoading === undefined ? false : _ref2$injectLoading,
      refreshFn = _ref2.refreshFn;

  var oldPolling = getPolling(dpId);
  var isFirst = _lodash2.default.isEmpty(getUsersForDp(dpId)) && !dataProviders[dpId].suspended();

  _lodash2.default.set(userConfigs, [userId, dpId], { needed: needed, polling: polling, injectLoading: injectLoading, refreshFn: refreshFn });
  if (keepAliveDp(dpId)) {
    keepAlivePollingMap[dpId] = Math.min(polling, keepAlivePolling(dpId));
  }
  dataProviders[dpId].updateUser(isFirst, needed, oldPolling);
}

// based on Data Provider settings, it either removes or disables user config with given userId
function removeDpUser(dpId, userId) {
  removeUser(dpId, userId);
  if (_lodash2.default.isEmpty(getUsersForDp(dpId))) {
    if (keepAliveDp(dpId)) {
      dataProviders[dpId].suspend();
    } else {
      removeDataProvider(dpId);
    }
  }
}

// removes the data provider from repository, when it expires
function dataProviderExpired(dpId) {
  removeDataProvider(dpId);
}

// triggers fetch() on a Data Provider with given ref
function refetch(dpRef) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = _lodash2.default.values(dataProviders)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var dp = _step3.value;

      if (_lodash2.default.isEqual(dp.ref, dpRef)) {
        return dp.fetch(true, true);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  throw new Error('No data provider ref=' + dpRef);
}

// internal

function removeUser(dpId, userId) {
  delete userConfigs[userId][dpId];
  if (_lodash2.default.isEmpty(userConfigs[userId])) {
    delete userConfigs[userId];
  }
}

function removeDataProvider(dpId) {
  delete dataProviders[dpId];
  delete keepAlivePollingMap[dpId];
}

function keepAlivePolling(dpId) {
  return keepAlivePollingMap[dpId] || Infinity;
}

function keepAliveDp(dpId) {
  return dataProviders[dpId] && dataProviders[dpId].keepAliveFor > 0;
}